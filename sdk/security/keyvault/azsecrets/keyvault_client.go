// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package azsecrets

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// KeyVaultClient - The key vault client performs cryptographic key operations and vault operations
// against the Key Vault service.
// Don't use this type directly, use a constructor function instead.
type KeyVaultClient struct {
	internal     *azcore.Client
	vaultBaseUrl string
}

// BackupSecret - Backs up the specified secret.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.2
//   - secretName - The name of the secret.
//   - options - KeyVaultClientBackupSecretOptions contains the optional parameters for the KeyVaultClient.BackupSecret method.
func (client *KeyVaultClient) BackupSecret(ctx context.Context, secretName string, options *KeyVaultClientBackupSecretOptions) (KeyVaultClientBackupSecretResponse, error) {
	var err error
	req, err := client.backupSecretCreateRequest(ctx, secretName, options)
	if err != nil {
		return KeyVaultClientBackupSecretResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientBackupSecretResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientBackupSecretResponse{}, err
	}
	resp, err := client.backupSecretHandleResponse(httpResp)
	return resp, err
}

// backupSecretCreateRequest creates the BackupSecret request.
func (client *KeyVaultClient) backupSecretCreateRequest(ctx context.Context, secretName string, _ *KeyVaultClientBackupSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/secrets/{secretName}/backup"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secretName}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// backupSecretHandleResponse handles the BackupSecret response.
func (client *KeyVaultClient) backupSecretHandleResponse(resp *http.Response) (KeyVaultClientBackupSecretResponse, error) {
	result := KeyVaultClientBackupSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupSecretResult); err != nil {
		return KeyVaultClientBackupSecretResponse{}, err
	}
	return result, nil
}

// DeleteSecret - Deletes a secret from a specified key vault.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.2
//   - secretName - The name of the secret.
//   - options - KeyVaultClientDeleteSecretOptions contains the optional parameters for the KeyVaultClient.DeleteSecret method.
func (client *KeyVaultClient) DeleteSecret(ctx context.Context, secretName string, options *KeyVaultClientDeleteSecretOptions) (KeyVaultClientDeleteSecretResponse, error) {
	var err error
	req, err := client.deleteSecretCreateRequest(ctx, secretName, options)
	if err != nil {
		return KeyVaultClientDeleteSecretResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientDeleteSecretResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientDeleteSecretResponse{}, err
	}
	resp, err := client.deleteSecretHandleResponse(httpResp)
	return resp, err
}

// deleteSecretCreateRequest creates the DeleteSecret request.
func (client *KeyVaultClient) deleteSecretCreateRequest(ctx context.Context, secretName string, _ *KeyVaultClientDeleteSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/secrets/{secretName}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secretName}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteSecretHandleResponse handles the DeleteSecret response.
func (client *KeyVaultClient) deleteSecretHandleResponse(resp *http.Response) (KeyVaultClientDeleteSecretResponse, error) {
	result := KeyVaultClientDeleteSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedSecretBundle); err != nil {
		return KeyVaultClientDeleteSecretResponse{}, err
	}
	return result, nil
}

// GetDeletedSecret - Gets the specified deleted secret.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.2
//   - secretName - The name of the secret.
//   - options - KeyVaultClientGetDeletedSecretOptions contains the optional parameters for the KeyVaultClient.GetDeletedSecret
//     method.
func (client *KeyVaultClient) GetDeletedSecret(ctx context.Context, secretName string, options *KeyVaultClientGetDeletedSecretOptions) (KeyVaultClientGetDeletedSecretResponse, error) {
	var err error
	req, err := client.getDeletedSecretCreateRequest(ctx, secretName, options)
	if err != nil {
		return KeyVaultClientGetDeletedSecretResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientGetDeletedSecretResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientGetDeletedSecretResponse{}, err
	}
	resp, err := client.getDeletedSecretHandleResponse(httpResp)
	return resp, err
}

// getDeletedSecretCreateRequest creates the GetDeletedSecret request.
func (client *KeyVaultClient) getDeletedSecretCreateRequest(ctx context.Context, secretName string, _ *KeyVaultClientGetDeletedSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/deletedsecrets/{secretName}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secretName}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedSecretHandleResponse handles the GetDeletedSecret response.
func (client *KeyVaultClient) getDeletedSecretHandleResponse(resp *http.Response) (KeyVaultClientGetDeletedSecretResponse, error) {
	result := KeyVaultClientGetDeletedSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedSecretBundle); err != nil {
		return KeyVaultClientGetDeletedSecretResponse{}, err
	}
	return result, nil
}

// NewGetDeletedSecretsPager - Lists deleted secrets for the specified vault.
//
// Generated from API version 7.6-preview.2
//   - options - KeyVaultClientGetDeletedSecretsOptions contains the optional parameters for the KeyVaultClient.NewGetDeletedSecretsPager
//     method.
func (client *KeyVaultClient) NewGetDeletedSecretsPager(options *KeyVaultClientGetDeletedSecretsOptions) *runtime.Pager[KeyVaultClientGetDeletedSecretsResponse] {
	return runtime.NewPager(runtime.PagingHandler[KeyVaultClientGetDeletedSecretsResponse]{
		More: func(page KeyVaultClientGetDeletedSecretsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *KeyVaultClientGetDeletedSecretsResponse) (KeyVaultClientGetDeletedSecretsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getDeletedSecretsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return KeyVaultClientGetDeletedSecretsResponse{}, err
			}
			return client.getDeletedSecretsHandleResponse(resp)
		},
	})
}

// getDeletedSecretsCreateRequest creates the GetDeletedSecrets request.
func (client *KeyVaultClient) getDeletedSecretsCreateRequest(ctx context.Context, options *KeyVaultClientGetDeletedSecretsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/deletedsecrets"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.2")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedSecretsHandleResponse handles the GetDeletedSecrets response.
func (client *KeyVaultClient) getDeletedSecretsHandleResponse(resp *http.Response) (KeyVaultClientGetDeletedSecretsResponse, error) {
	result := KeyVaultClientGetDeletedSecretsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PagedDeletedSecretItem); err != nil {
		return KeyVaultClientGetDeletedSecretsResponse{}, err
	}
	return result, nil
}

// GetSecret - Get a specified secret from a given key vault.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.2
//   - secretName - The name of the secret.
//   - secretVersion - The version of the secret. This URI fragment is optional. If not specified, the
//     latest version of the secret is returned.
//   - options - KeyVaultClientGetSecretOptions contains the optional parameters for the KeyVaultClient.GetSecret method.
func (client *KeyVaultClient) GetSecret(ctx context.Context, secretName string, secretVersion string, options *KeyVaultClientGetSecretOptions) (KeyVaultClientGetSecretResponse, error) {
	var err error
	req, err := client.getSecretCreateRequest(ctx, secretName, secretVersion, options)
	if err != nil {
		return KeyVaultClientGetSecretResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientGetSecretResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientGetSecretResponse{}, err
	}
	resp, err := client.getSecretHandleResponse(httpResp)
	return resp, err
}

// getSecretCreateRequest creates the GetSecret request.
func (client *KeyVaultClient) getSecretCreateRequest(ctx context.Context, secretName string, secretVersion string, _ *KeyVaultClientGetSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/secrets/{secretName}/{secretVersion}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secretName}", url.PathEscape(secretName))
	if secretVersion == "" {
		return nil, errors.New("parameter secretVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secretVersion}", url.PathEscape(secretVersion))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSecretHandleResponse handles the GetSecret response.
func (client *KeyVaultClient) getSecretHandleResponse(resp *http.Response) (KeyVaultClientGetSecretResponse, error) {
	result := KeyVaultClientGetSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SecretBundle); err != nil {
		return KeyVaultClientGetSecretResponse{}, err
	}
	return result, nil
}

// NewGetSecretVersionsPager - List all versions of the specified secret.
//
// Generated from API version 7.6-preview.2
//   - secretName - The name of the secret.
//   - options - KeyVaultClientGetSecretVersionsOptions contains the optional parameters for the KeyVaultClient.NewGetSecretVersionsPager
//     method.
func (client *KeyVaultClient) NewGetSecretVersionsPager(secretName string, options *KeyVaultClientGetSecretVersionsOptions) *runtime.Pager[KeyVaultClientGetSecretVersionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[KeyVaultClientGetSecretVersionsResponse]{
		More: func(page KeyVaultClientGetSecretVersionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *KeyVaultClientGetSecretVersionsResponse) (KeyVaultClientGetSecretVersionsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getSecretVersionsCreateRequest(ctx, secretName, options)
			}, nil)
			if err != nil {
				return KeyVaultClientGetSecretVersionsResponse{}, err
			}
			return client.getSecretVersionsHandleResponse(resp)
		},
	})
}

// getSecretVersionsCreateRequest creates the GetSecretVersions request.
func (client *KeyVaultClient) getSecretVersionsCreateRequest(ctx context.Context, secretName string, options *KeyVaultClientGetSecretVersionsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/secrets/{secretName}/versions"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secretName}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.2")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSecretVersionsHandleResponse handles the GetSecretVersions response.
func (client *KeyVaultClient) getSecretVersionsHandleResponse(resp *http.Response) (KeyVaultClientGetSecretVersionsResponse, error) {
	result := KeyVaultClientGetSecretVersionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SecretListResult); err != nil {
		return KeyVaultClientGetSecretVersionsResponse{}, err
	}
	return result, nil
}

// NewGetSecretsPager - List secrets in a specified key vault.
//
// Generated from API version 7.6-preview.2
//   - options - KeyVaultClientGetSecretsOptions contains the optional parameters for the KeyVaultClient.NewGetSecretsPager method.
func (client *KeyVaultClient) NewGetSecretsPager(options *KeyVaultClientGetSecretsOptions) *runtime.Pager[KeyVaultClientGetSecretsResponse] {
	return runtime.NewPager(runtime.PagingHandler[KeyVaultClientGetSecretsResponse]{
		More: func(page KeyVaultClientGetSecretsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *KeyVaultClientGetSecretsResponse) (KeyVaultClientGetSecretsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getSecretsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return KeyVaultClientGetSecretsResponse{}, err
			}
			return client.getSecretsHandleResponse(resp)
		},
	})
}

// getSecretsCreateRequest creates the GetSecrets request.
func (client *KeyVaultClient) getSecretsCreateRequest(ctx context.Context, options *KeyVaultClientGetSecretsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/secrets"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.2")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSecretsHandleResponse handles the GetSecrets response.
func (client *KeyVaultClient) getSecretsHandleResponse(resp *http.Response) (KeyVaultClientGetSecretsResponse, error) {
	result := KeyVaultClientGetSecretsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PagedSecretItem); err != nil {
		return KeyVaultClientGetSecretsResponse{}, err
	}
	return result, nil
}

// PurgeDeletedSecret - Permanently deletes the specified secret.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.2
//   - secretName - The name of the secret.
//   - options - KeyVaultClientPurgeDeletedSecretOptions contains the optional parameters for the KeyVaultClient.PurgeDeletedSecret
//     method.
func (client *KeyVaultClient) PurgeDeletedSecret(ctx context.Context, secretName string, options *KeyVaultClientPurgeDeletedSecretOptions) (KeyVaultClientPurgeDeletedSecretResponse, error) {
	var err error
	req, err := client.purgeDeletedSecretCreateRequest(ctx, secretName, options)
	if err != nil {
		return KeyVaultClientPurgeDeletedSecretResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientPurgeDeletedSecretResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientPurgeDeletedSecretResponse{}, err
	}
	return KeyVaultClientPurgeDeletedSecretResponse{}, nil
}

// purgeDeletedSecretCreateRequest creates the PurgeDeletedSecret request.
func (client *KeyVaultClient) purgeDeletedSecretCreateRequest(ctx context.Context, secretName string, _ *KeyVaultClientPurgeDeletedSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/deletedsecrets/{secretName}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secretName}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// RecoverDeletedSecret - Recovers the deleted secret to the latest version.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.2
//   - secretName - The name of the deleted secret.
//   - options - KeyVaultClientRecoverDeletedSecretOptions contains the optional parameters for the KeyVaultClient.RecoverDeletedSecret
//     method.
func (client *KeyVaultClient) RecoverDeletedSecret(ctx context.Context, secretName string, options *KeyVaultClientRecoverDeletedSecretOptions) (KeyVaultClientRecoverDeletedSecretResponse, error) {
	var err error
	req, err := client.recoverDeletedSecretCreateRequest(ctx, secretName, options)
	if err != nil {
		return KeyVaultClientRecoverDeletedSecretResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientRecoverDeletedSecretResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientRecoverDeletedSecretResponse{}, err
	}
	resp, err := client.recoverDeletedSecretHandleResponse(httpResp)
	return resp, err
}

// recoverDeletedSecretCreateRequest creates the RecoverDeletedSecret request.
func (client *KeyVaultClient) recoverDeletedSecretCreateRequest(ctx context.Context, secretName string, _ *KeyVaultClientRecoverDeletedSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/deletedsecrets/{secretName}/recover"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secretName}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// recoverDeletedSecretHandleResponse handles the RecoverDeletedSecret response.
func (client *KeyVaultClient) recoverDeletedSecretHandleResponse(resp *http.Response) (KeyVaultClientRecoverDeletedSecretResponse, error) {
	result := KeyVaultClientRecoverDeletedSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SecretBundle); err != nil {
		return KeyVaultClientRecoverDeletedSecretResponse{}, err
	}
	return result, nil
}

// RestoreSecret - Restores a backed up secret to a vault.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.2
//   - parameters - The parameters to restore the secret.
//   - options - KeyVaultClientRestoreSecretOptions contains the optional parameters for the KeyVaultClient.RestoreSecret method.
func (client *KeyVaultClient) RestoreSecret(ctx context.Context, parameters SecretRestoreParameters, options *KeyVaultClientRestoreSecretOptions) (KeyVaultClientRestoreSecretResponse, error) {
	var err error
	req, err := client.restoreSecretCreateRequest(ctx, parameters, options)
	if err != nil {
		return KeyVaultClientRestoreSecretResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientRestoreSecretResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientRestoreSecretResponse{}, err
	}
	resp, err := client.restoreSecretHandleResponse(httpResp)
	return resp, err
}

// restoreSecretCreateRequest creates the RestoreSecret request.
func (client *KeyVaultClient) restoreSecretCreateRequest(ctx context.Context, parameters SecretRestoreParameters, _ *KeyVaultClientRestoreSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/secrets/restore"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// restoreSecretHandleResponse handles the RestoreSecret response.
func (client *KeyVaultClient) restoreSecretHandleResponse(resp *http.Response) (KeyVaultClientRestoreSecretResponse, error) {
	result := KeyVaultClientRestoreSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SecretBundle); err != nil {
		return KeyVaultClientRestoreSecretResponse{}, err
	}
	return result, nil
}

// SetSecret - Sets a secret in a specified key vault.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.2
//   - secretName - The name of the secret. The value you provide may be copied globally for the
//     purpose of running the service. The value provided should not include
//     personally identifiable or sensitive information.
//   - parameters - The parameters for setting the secret.
//   - options - KeyVaultClientSetSecretOptions contains the optional parameters for the KeyVaultClient.SetSecret method.
func (client *KeyVaultClient) SetSecret(ctx context.Context, secretName string, parameters SecretSetParameters, options *KeyVaultClientSetSecretOptions) (KeyVaultClientSetSecretResponse, error) {
	var err error
	req, err := client.setSecretCreateRequest(ctx, secretName, parameters, options)
	if err != nil {
		return KeyVaultClientSetSecretResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientSetSecretResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientSetSecretResponse{}, err
	}
	resp, err := client.setSecretHandleResponse(httpResp)
	return resp, err
}

// setSecretCreateRequest creates the SetSecret request.
func (client *KeyVaultClient) setSecretCreateRequest(ctx context.Context, secretName string, parameters SecretSetParameters, _ *KeyVaultClientSetSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/secrets/{secretName}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secretName}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// setSecretHandleResponse handles the SetSecret response.
func (client *KeyVaultClient) setSecretHandleResponse(resp *http.Response) (KeyVaultClientSetSecretResponse, error) {
	result := KeyVaultClientSetSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SecretBundle); err != nil {
		return KeyVaultClientSetSecretResponse{}, err
	}
	return result, nil
}

// UpdateSecret - Updates the attributes associated with a specified secret in a given key vault.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.2
//   - secretName - The name of the secret.
//   - secretVersion - The version of the secret.
//   - parameters - The parameters for update secret operation.
//   - options - KeyVaultClientUpdateSecretOptions contains the optional parameters for the KeyVaultClient.UpdateSecret method.
func (client *KeyVaultClient) UpdateSecret(ctx context.Context, secretName string, secretVersion string, parameters SecretUpdateParameters, options *KeyVaultClientUpdateSecretOptions) (KeyVaultClientUpdateSecretResponse, error) {
	var err error
	req, err := client.updateSecretCreateRequest(ctx, secretName, secretVersion, parameters, options)
	if err != nil {
		return KeyVaultClientUpdateSecretResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientUpdateSecretResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientUpdateSecretResponse{}, err
	}
	resp, err := client.updateSecretHandleResponse(httpResp)
	return resp, err
}

// updateSecretCreateRequest creates the UpdateSecret request.
func (client *KeyVaultClient) updateSecretCreateRequest(ctx context.Context, secretName string, secretVersion string, parameters SecretUpdateParameters, _ *KeyVaultClientUpdateSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/secrets/{secretName}/{secretVersion}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secretName}", url.PathEscape(secretName))
	if secretVersion == "" {
		return nil, errors.New("parameter secretVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secretVersion}", url.PathEscape(secretVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// updateSecretHandleResponse handles the UpdateSecret response.
func (client *KeyVaultClient) updateSecretHandleResponse(resp *http.Response) (KeyVaultClientUpdateSecretResponse, error) {
	result := KeyVaultClientUpdateSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SecretBundle); err != nil {
		return KeyVaultClientUpdateSecretResponse{}, err
	}
	return result, nil
}
